"""
Utility functions for language learning features.
"""

from typing import Dict, Any, List, Optional, Tuple
import re
import logging
from pathlib import Path
import json

from app.api.llm import LLMClient


logger = logging.getLogger(__name__)


def extract_vocabulary(text: str) -> List[str]:
    """
    Extract vocabulary words from Japanese text.
    
    Args:
        text: Japanese text
        
    Returns:
        List of vocabulary words
    """
    # Simple implementation - split by spaces and remove punctuation
    # In a real implementation, this would use a Japanese tokenizer
    words = re.findall(r'[ぁ-んァ-ンー一-龯]+', text)
    return list(set(words))


def get_word_info(
    word: str,
    llm_client: Optional[LLMClient] = None,
    vocabulary_db: Optional[Path] = None
) -> Dict[str, Any]:
    """
    Get information about a Japanese word.
    
    Args:
        word: Japanese word
        llm_client: LLM client for generating word information
        vocabulary_db: Path to vocabulary database
        
    Returns:
        Dictionary with word information
    """
    # Try to get from local database first
    if vocabulary_db:
        word_info = _get_word_from_db(word, vocabulary_db)
        if word_info:
            return word_info
    
    # Fall back to LLM if available
    if llm_client:
        try:
            return _get_word_from_llm(word, llm_client)
        except Exception as e:
            logger.error(f"Error getting word info from LLM: {e}")
    
    # Return basic structure if nothing else works
    return {
        "word": word,
        "reading": "",
        "meaning": "",
        "part_of_speech": "",
        "level": "unknown"
    }


def _get_word_from_db(word: str, vocabulary_db: Path) -> Optional[Dict[str, Any]]:
    """
    Get word information from local database.
    
    Args:
        word: Japanese word
        vocabulary_db: Path to vocabulary database
        
    Returns:
        Dictionary with word information or None if not found
    """
    if not vocabulary_db.exists():
        return None
        
    try:
        with open(vocabulary_db, "r", encoding="utf-8") as f:
            vocab_data = json.load(f)
            
        return vocab_data.get(word)
    except Exception as e:
        logger.error(f"Error reading vocabulary database: {e}")
        return None


def _get_word_from_llm(word: str, llm_client: LLMClient) -> Dict[str, Any]:
    """
    Get word information from LLM.
    
    Args:
        word: Japanese word
        llm_client: LLM client
        
    Returns:
        Dictionary with word information
    """
    # This would call the LLM to get information about the word
    # For now, return a placeholder
    return {
        "word": word,
        "reading": "",
        "meaning": "Generated by LLM",
        "part_of_speech": "",
        "level": "unknown"
    }


def get_pronunciation_guide(
    text: str,
    llm_client: Optional[LLMClient] = None
) -> str:
    """
    Get pronunciation guide for Japanese text.
    
    Args:
        text: Japanese text
        llm_client: LLM client
        
    Returns:
        Pronunciation guide (romaji)
    """
    if llm_client:
        try:
            return llm_client.get_pronunciation(text)
        except Exception as e:
            logger.error(f"Error getting pronunciation from LLM: {e}")
    
    # Return original text if LLM not available
    return text


def translate_text(
    text: str,
    source_lang: str = "ja",
    target_lang: str = "en",
    llm_client: Optional[LLMClient] = None
) -> str:
    """
    Translate text between languages.
    
    Args:
        text: Text to translate
        source_lang: Source language code
        target_lang: Target language code
        llm_client: LLM client
        
    Returns:
        Translated text
    """
    if llm_client:
        try:
            return llm_client.translate_text(
                text=text,
                source_lang=source_lang,
                target_lang=target_lang
            )
        except Exception as e:
            logger.error(f"Error translating text with LLM: {e}")
    
    # Return original text if LLM not available
    return text


def analyze_sentence_structure(
    sentence: str,
    llm_client: Optional[LLMClient] = None
) -> Dict[str, Any]:
    """
    Analyze the grammatical structure of a Japanese sentence.
    
    Args:
        sentence: Japanese sentence
        llm_client: LLM client
        
    Returns:
        Dictionary with sentence analysis
    """
    if not llm_client:
        return {"sentence": sentence, "analysis": "LLM client not available"}
        
    try:
        # This would call the LLM to analyze the sentence
        # For now, return a placeholder
        return {
            "sentence": sentence,
            "analysis": "Sentence structure analysis would be provided by LLM",
            "grammar_points": []
        }
    except Exception as e:
        logger.error(f"Error analyzing sentence with LLM: {e}")
        return {"sentence": sentence, "analysis": f"Error: {str(e)}"}


def track_learned_vocabulary(
    word: str,
    is_correct: bool,
    player_data: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Track learned vocabulary for the player.
    
    Args:
        word: Japanese word
        is_correct: Whether the player answered correctly
        player_data: Player data dictionary
        
    Returns:
        Updated player data
    """
    if "learned_words" not in player_data:
        player_data["learned_words"] = []
        
    # Check if word is already in learned words
    word_entry = None
    for entry in player_data["learned_words"]:
        if entry["word"] == word:
            word_entry = entry
            break
            
    if not word_entry:
        word_entry = {
            "word": word,
            "correct_count": 0,
            "incorrect_count": 0,
            "last_seen": None,
            "mastery_level": 0  # 0-5 scale
        }
        player_data["learned_words"].append(word_entry)
        
    # Update counts
    if is_correct:
        word_entry["correct_count"] += 1
    else:
        word_entry["incorrect_count"] += 1
        
    # Update mastery level based on correct/incorrect ratio
    total = word_entry["correct_count"] + word_entry["incorrect_count"]
    if total >= 5:
        ratio = word_entry["correct_count"] / total
        if ratio > 0.9:
            word_entry["mastery_level"] = 5
        elif ratio > 0.8:
            word_entry["mastery_level"] = 4
        elif ratio > 0.7:
            word_entry["mastery_level"] = 3
        elif ratio > 0.6:
            word_entry["mastery_level"] = 2
        elif ratio > 0.5:
            word_entry["mastery_level"] = 1
        else:
            word_entry["mastery_level"] = 0
            
    # Update last seen timestamp
    from datetime import datetime
    word_entry["last_seen"] = datetime.now().isoformat()
    
    return player_data 